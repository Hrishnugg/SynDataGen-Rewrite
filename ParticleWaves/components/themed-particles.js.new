import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

const WaveformParticles = ({ theme = 'dark' }) => {
  const mountRef = useRef(null);
  const mouseRef = useRef(new THREE.Vector3(999, 999, 0)); // Start off-screen
  const themeRef = useRef(theme); // Store theme in ref to access in cleanup
  
  // Define constants at component level to ensure they're in scope everywhere
  const WAVE_COUNT = 5;
  const PARTICLES_PER_WAVE = 4000;
  const BACKGROUND_PARTICLE_COUNT = 3000;
  
  // Add debug logging function
  const logPositionData = (scene, camera, waves, backgroundParticleSystem, visibleWidthAtZDepth, visibleHeightAtZDepth, calculatedWidth) => {
    console.log('--- POSITION DEBUGGING ---');
    console.log('Viewport Dimensions:', {
      clientWidth: mountRef.current?.clientWidth,
      clientHeight: mountRef.current?.clientHeight,
      aspect: camera.aspect,
      visibleWidthAtZDepth,
      visibleHeightAtZDepth,
      calculatedWidth,
    });
    
    console.log('Camera Settings:', {
      position: camera.position.toArray(),
      fov: camera.fov,
      near: camera.near,
      far: camera.far,
    });
    
    // Track position bounds of wave particles
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    waves.forEach((wave, index) => {
      const positions = wave.geometry.attributes.position.array;
      
      for (let i = 0; i < positions.length; i += 3) {
        minX = Math.min(minX, positions[i]);
        maxX = Math.max(maxX, positions[i]);
        minY = Math.min(minY, positions[i + 1]);
        maxY = Math.max(maxY, positions[i + 1]);
        minZ = Math.min(minZ, positions[i + 2]);
        maxZ = Math.max(maxZ, positions[i + 2]);
      }
      
      // Log specific ranges for this wave
      console.log(`Wave ${index} Position Range:`, {
        x: [minX, maxX],
        y: [minY, maxY],
        z: [minZ, maxZ]
      });
    });
    
    console.log('Overall Wave Particles Range:', {
      x: [minX, maxX],
      y: [minY, maxY],
      z: [minZ, maxZ]
    });
    
    // Check if background particles exist and log their ranges too
    if (backgroundParticleSystem && backgroundParticleSystem.geometry) {
      const bgPositions = backgroundParticleSystem.geometry.attributes.position.array;
      let bgMinX = Infinity, bgMaxX = -Infinity;
      let bgMinY = Infinity, bgMaxY = -Infinity;
      let bgMinZ = Infinity, bgMaxZ = -Infinity;
      
      for (let i = 0; i < bgPositions.length; i += 3) {
        bgMinX = Math.min(bgMinX, bgPositions[i]);
        bgMaxX = Math.max(bgMaxX, bgPositions[i]);
        bgMinY = Math.min(bgMinY, bgPositions[i + 1]);
        bgMaxY = Math.max(bgMaxY, bgPositions[i + 1]);
        bgMinZ = Math.min(bgMinZ, bgPositions[i + 2]);
        bgMaxZ = Math.max(bgMaxZ, bgPositions[i + 2]);
      }
      
      console.log('Background Particles Range:', {
        x: [bgMinX, bgMaxX],
        y: [bgMinY, bgMaxY],
        z: [bgMinZ, bgMaxZ]
      });
    }
    
    // Log scene hierarchies and transforms
    console.log('Scene Hierarchy:', {
      scenePosition: scene.position.toArray(),
      sceneRotation: scene.rotation.toArray(),
      sceneScale: scene.scale.toArray(),
      childCount: scene.children.length
    });
    
    // Log container transformations when available
    scene.children.forEach((child, index) => {
      if (child.type === 'Object3D') {
        console.log(`Scene Container ${index}:`, {
          position: child.position.toArray(),
          rotation: child.rotation.toArray(),
          scale: child.scale.toArray(),
          childCount: child.children.length
        });
      }
    });
  };
  
  useEffect(() => {
    if (!mountRef.current) return;
    
    // Update theme reference
    console.log('Initializing ThemedParticles with theme:', theme);
    console.log(`DEBUG: WebGL Renderer Parameters:`, {
      alpha: true,
      premultipliedAlpha: false,
      antialias: true,
      theme: theme,
      pixelRatio: Math.min(window.devicePixelRatio, 2)
    });
    
    themeRef.current = theme;
    
    // Scene setup
    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;
    
    // Guard against zero dimensions which cause framebuffer errors
    if (width === 0 || height === 0) {
      console.warn('Container has zero width or height. Delaying initialization.');
      // Use a ResizeObserver to wait for proper dimensions
      const resizeObserver = new ResizeObserver((entries) => {
        const { width, height } = entries[0].contentRect;
        if (width > 0 && height > 0) {
          resizeObserver.disconnect();
          // Re-trigger effect to initialize with proper dimensions
          mountRef.current.dataset.ready = 'true';
        }
      });
      
      resizeObserver.observe(mountRef.current);
      return;
    }
    
    console.log('Initializing with container dimensions:', { width, height });
    
    const scene = new THREE.Scene();
    
    // Set scene properties based on theme
    if (theme === 'light') {
      // Special handling for light theme
      scene.background = new THREE.Color(0xffffff);
      scene.environment = null;
      scene.fog = null;
      console.log('DEBUG: Using light mode specific scene settings');
    } else {
      // Dark theme settings
      scene.background = new THREE.Color(0x000011);
      scene.fog = null;
      console.log('DEBUG: Using dark mode specific scene settings');
    }
    
    // Create a camera that's centered and positioned properly
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    
    // Calculate optimal camera position based on screen aspect ratio
    // Further increase camera distance to ensure proper viewing at 100% zoom
    const cameraDistance = 80; // Increased from 75 to create an even more zoomed-out view
    const aspectRatio = width / height;
    
    // Determine orientation early to use throughout the component
    const isLandscape = aspectRatio > 1;
    
    // CORRECTED CAMERA POSITIONING: Set camera directly on z-axis pointing at origin
    // This ensures the camera is properly centered on the scene
    camera.position.set(0, 0, cameraDistance);
    camera.lookAt(0, 0, 0);
    
    console.log('Camera position corrected:', {
      position: camera.position.toArray(),
      lookAt: [0, 0, 0]
    });
    
    // Create a centered scene container to help with positioning
    const sceneContainer = new THREE.Object3D();
    // CRITICAL FIX: Reset the scene container position to absolute zero
    // This ensures no unwanted offsets are applied
    sceneContainer.position.set(0, 0, 0);
    scene.add(sceneContainer);
    
    // Add a grid helper to visualize the coordinate system
    const gridHelper = new THREE.GridHelper(100, 10, 0x444444, 0x222222);
    gridHelper.position.set(0, 0, 0);
    gridHelper.visible = false; // Hide grid helper
    scene.add(gridHelper);
    
    // Calculate the visible width and height at the z=0 plane
    // This is critical for proper sizing across different zoom levels
    const fovRadians = camera.fov * Math.PI / 180;
    const visibleHeightAtZDepth = 2 * Math.tan(fovRadians / 2) * cameraDistance;
    // CRITICAL FIX: Apply correction factor to ensure viewport calculations match the actual visible area at 100% zoom
    // This ensures the right edge marker (green) stays on screen at normal zoom
    const viewportCorrectionFactor = 1.0; // Increased from 0.95 to fill the viewport completely
    const visibleWidthAtZDepth = visibleHeightAtZDepth * camera.aspect * viewportCorrectionFactor;
    
    console.log('Calculated visible dimensions:', {
      visibleWidthAtZDepth,
      visibleHeightAtZDepth,
      aspectRatio,
      isLandscape,
      viewportCorrectionFactor
    });
    
    // *** CORRECTED POSITIONING LOGIC ***
    // Center the scene properly by setting the correct global offset
    // This addresses the root cause of the right-shift issue
    const globalCenterOffsetX = 0; // Eliminated offset that was causing right-shift
    
    // Create a centered scene container to help with positioning
    // Apply corrected positioning to ensure scene is centered in viewport
    sceneContainer.position.set(globalCenterOffsetX, 0, 0);
    
    // Log the corrected scene position for debugging
    console.log('Corrected scene container position:', {
      globalCenterOffsetX,
      sceneContainerPosition: sceneContainer.position.toArray()
    });
    
    // Apply a viewport correction factor calibrated for 100% zoom
    // Further reduce correction factors to prevent overflow
    const baseSize = (isLandscape ? visibleHeightAtZDepth : visibleWidthAtZDepth) * viewportCorrectionFactor;
    
    console.log('Viewport correction factors:', {
      viewportCorrectionFactor,
      baseSize
    });
    
    // Create renderer with proper settings for high-quality rendering
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: theme === 'light', // Only use alpha for light theme
      premultipliedAlpha: false, // Disable premultiplied alpha which can cause blending issues
      preserveDrawingBuffer: theme === 'light', // Preserve drawing buffer in light mode to prevent artifacts
      powerPreference: 'high-performance'
    });
    
    // Calculate and set pixel ratio (clamped for performance)
    const pixelRatio = Math.min(window.devicePixelRatio, 2);
    renderer.setPixelRatio(pixelRatio);
    
    // CRITICAL FIX: Ensure the renderer is properly set up with defaults that don't cause shifting
    renderer.autoClear = true;
    renderer.setClearColor(theme === 'light' ? 0xffffff : 0x000011, 1); // Match scene background for consistency
    renderer.sortObjects = true; // Ensure objects are sorted properly for transparency
    
    // Set light-mode specific renderer settings
    if (theme === 'light') {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping; // Disable tone mapping for light mode
      console.log('DEBUG: Using light mode specific renderer settings');
    } else {
      renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      console.log('DEBUG: Using dark mode specific renderer settings');
    }
    
    // Set initial size matched to container dimensions (CSS will scale canvas properly)
    renderer.setSize(width, height, false); // false prevents setting canvas style
    
    // CRITICAL FIX: Add explicit CSS styles to the renderer's canvas to ensure proper centering
    renderer.domElement.style.position = 'absolute';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
    
    // Append the renderer's canvas to our mount point
    mountRef.current.appendChild(renderer.domElement);
    
    console.log(`DEBUG: Initial renderer settings for ${theme} mode:`, {
      autoClear: renderer.autoClear,
      clearColor: renderer.getClearColor(new THREE.Color()).getHexString(),
      alpha: renderer.domElement.style.backgroundColor ? 'set' : 'not set',
      sortObjects: renderer.sortObjects,
      premultipliedAlpha: renderer.domElement.style.backgroundColor === 'premultiplied'
    });
    
    // Force an initial clear with the correct background color
    // This helps prevent the box artifact on initial render in light mode
    renderer.setClearColor(theme === 'light' ? 0xffffff : 0x000011, 1);
    renderer.clear(true, true, true);
    
    console.log(`DEBUG: After initial clear for ${theme} mode`);
    
    // Create post-processing composer with the same pixel ratio
    const composer = new EffectComposer(renderer);
    composer.setPixelRatio(pixelRatio);
    composer.setSize(width, height);
    
    // Configure separate rendering pipelines for light and dark modes
    if (theme === 'light') {
      console.log('DEBUG: Setting up light mode post-processing');
      
      // Use a simplified pipeline for light mode - just a render pass
      const renderPass = new RenderPass(scene, camera);
      renderPass.clearColor = new THREE.Color(0xffffff);
      renderPass.clearAlpha = 1.0;
      composer.addPass(renderPass);
      
      // Add bloom with more conservative settings for light mode
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(width, height),
        0.6,  // reduced strength
        0.4,  // increased radius 
        0.9   // increased threshold
      );
      // Don't render to screen - we'll use direct rendering
      bloomPass.renderToScreen = false; 
      composer.addPass(bloomPass);
    } else {
      console.log('DEBUG: Setting up dark mode post-processing');
      
      // Use full post-processing for dark mode
      const renderPass = new RenderPass(scene, camera);
      renderPass.clearColor = new THREE.Color(0x000011);
      renderPass.clearAlpha = 1.0;
      composer.addPass(renderPass);
      
      // Add bloom with stronger settings for dark mode
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(width, height),
        0.8,  // strength 
        0.3,  // radius
        0.8   // threshold
      );
      bloomPass.renderToScreen = true;
      composer.addPass(bloomPass);
    }
    
    // Only proceed with rendering if dimensions are valid
    if (renderer.domElement.width === 0 || renderer.domElement.height === 0) {
      console.warn('Canvas has zero dimensions, cannot initialize composer');
      return;
    }
    
    // Common Y values for all waves to start and end at
    const commonStartY = 0;
    const commonEndY = 0;
    
    // Scale factor to ensure waves fit properly on the screen based on orientation
    // Further reduce scale to ensure proper centering at 100% zoom
    const waveScale = isLandscape ? 0.65 : 0.75; // Further reduced from 0.7/0.8 for better containment
    
    console.log('Wave scale factor:', waveScale);
    
    // Add slight padding to ensure waves extend just beyond screen edges
    // Further reduce width factor to fit properly at normal zoom level
    // Calculate width based on already-corrected visibleWidthAtZDepth value
    const screenWidthFactor = isLandscape ? 0.85 : 0.85; // Increased for better visibility at 100% zoom
    const calculatedWidth = visibleWidthAtZDepth * screenWidthFactor;
    
    console.log('Wave width calculation:', {
      screenWidthFactor,
      calculatedWidth,
      visibleWidthAtZDepth
    });
    
    // No offset needed for centering as we've corrected the scene positioning approach
    
    // Create a container for waves that adapts to screen orientation
    const wavesContainer = new THREE.Object3D();
    // Position the container precisely at the center of the scene
    wavesContainer.position.set(0, 0, 0);
    sceneContainer.add(wavesContainer);
    
    // Add a visual debug object if needed to verify centering
    const debugCenter = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 8, 8),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    debugCenter.visible = false; // Hide center point visualization
    wavesContainer.add(debugCenter);
    
    // Add visual indicators for viewport boundaries
    const addViewportBoundaryMarkers = () => {
      // Create markers for the calculated viewport edges
      const markerGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      
      // Left edge marker (red)
      const leftMarker = new THREE.Mesh(
        markerGeometry,
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      // Position markers using corrected viewport dimensions to ensure they're visible at 100% zoom
      leftMarker.position.set(-visibleWidthAtZDepth/2, 0, 0);
      leftMarker.name = 'leftMarker'; // Add name for easy identification
      leftMarker.visible = false; // Hide debug marker
      scene.add(leftMarker);
      
      // Right edge marker (green)
      const rightMarker = new THREE.Mesh(
        markerGeometry, 
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      rightMarker.position.set(visibleWidthAtZDepth/2, 0, 0);
      rightMarker.name = 'rightMarker'; // Add name for easy identification
      rightMarker.visible = false; // Hide debug marker
      scene.add(rightMarker);
      
      // Center marker (blue)
      const originMarker = new THREE.Mesh(
        markerGeometry,
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
      );
      originMarker.position.set(0, 0, 0);
      originMarker.name = 'originMarker'; // Add name for easy identification
      originMarker.visible = false; // Hide debug marker
      scene.add(originMarker);
      
      // CRITICAL DEBUG: Add a horizontal line spanning the viewport width
      // This helps visualize the true center and width
      const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
      const points = [];
      points.push(new THREE.Vector3(-visibleWidthAtZDepth/2, 0, 0));
      points.push(new THREE.Vector3(visibleWidthAtZDepth/2, 0, 0));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);
      line.name = 'centerLine';
      line.visible = false; // Hide debug line
      scene.add(line);
      
      // Log viewport boundaries for reference
      console.log('Viewport boundary markers added:', {
        leftEdge: -visibleWidthAtZDepth/2,
        rightEdge: visibleWidthAtZDepth/2,
        center: 0,
        visibleWidthAtZDepth
      });
    };
    
    // Add the boundary markers to help diagnose positioning
    addViewportBoundaryMarkers();
    
    // Function to determine if a particle needs to be constrained within bounds
    const constrainParticlePosition = (particleSystem, visibleWidthAtZDepth, visibleHeightAtZDepth) => {
      if (!particleSystem || !particleSystem.geometry) return false;
      
      const positions = particleSystem.geometry.attributes.position.array;
      let wasConstrained = false;
      
      // Calculate maximum allowed positions based on viewport dimensions
      // Allow particles to go slightly closer to the edges with the new scaling
      const maxAllowedX = visibleWidthAtZDepth * 0.48; // Increased from 0.45 to allow particles closer to edges
      const maxAllowedY = visibleHeightAtZDepth * 0.48; // Increased from 0.45 to allow particles closer to edges
      const maxAllowedZ = 40; // Increased from 35 for better depth
      
      for (let i = 0; i < positions.length; i += 3) {
        // Check X bounds - more aggressively constrain
        if (Math.abs(positions[i]) > maxAllowedX) {
          // Move particle back inside bounds with a small random offset to prevent hard edge
          positions[i] = Math.sign(positions[i]) * (maxAllowedX - 2 - Math.random() * 3);
          wasConstrained = true;
        }
        
        // Check Y bounds
        if (Math.abs(positions[i + 1]) > maxAllowedY) {
          positions[i + 1] = Math.sign(positions[i + 1]) * (maxAllowedY - 2 - Math.random() * 3);
          wasConstrained = true;
        }
        
        // Check Z bounds
        if (Math.abs(positions[i + 2]) > maxAllowedZ) {
          positions[i + 2] = Math.sign(positions[i + 2]) * (maxAllowedZ - 2 - Math.random() * 3);
          wasConstrained = true;
        }
      }
      
      if (wasConstrained) {
        particleSystem.geometry.attributes.position.needsUpdate = true;
      }
      
      return wasConstrained;
    };
    
    // Fine-tune overall scene position for perfect centering at 100% zoom
    // This ensures the scene looks correct at the most common zoom level
    // scene.position.x = isLandscape ? 0 : 0.5; // This line is no longer needed
    
    // Define colors based on theme
    const colors = theme === 'light' 
      ? [
          new THREE.Color(0xffffff), // white
          new THREE.Color(0xd9e9ff), // very light blue
          new THREE.Color(0xa3c9ff), // light blue
          new THREE.Color(0x4d94ff), // medium blue
          new THREE.Color(0x0066ff), // bright blue
          new THREE.Color(0x0047cc), // dark blue
          new THREE.Color(0x003380)  // deeper blue
        ]
      : [
          new THREE.Color(0xffffff), // white
          new THREE.Color(0xa6d8ff), // light blue
          new THREE.Color(0x4d94ff), // medium blue
          new THREE.Color(0x0047ab), // dark blue
          new THREE.Color(0xff69b4), // hot pink
          new THREE.Color(0xff1493), // deep pink
          new THREE.Color(0xff00ff)  // magenta
        ];
    
    // Define specific colors for smooth interpolation based on theme
    let leftColor, centerColor, rightColor;
    
    if (theme === 'light') {
      leftColor = new THREE.Color(0x003380);  // Darker blue for left side
      centerColor = new THREE.Color(0xf0f8ff); // Alice blue tint for center
      rightColor = new THREE.Color(0x4d94ff);  // Medium blue for right side
    } else {
      leftColor = new THREE.Color(0xff00ff);  // Magenta for left side
      centerColor = new THREE.Color(0xf0f0ff); // Slightly blue-tinted white for center
      rightColor = new THREE.Color(0x0047ab);  // Blue for right side
    }
    
    // Helper function for smooth color interpolation
    const lerpColor = (colorA, colorB, t) => {
      const result = new THREE.Color();
      result.r = colorA.r + (colorB.r - colorA.r) * t;
      result.g = colorA.g + (colorB.g - colorA.g) * t;
      result.b = colorA.b + (colorB.b - colorA.b) * t;
      return result;
    };
    
    // Create waves and add them to the container for proper positioning
    const waves = [];
    
    // Log tracking for wave particle positions
    let waveParticleRanges = {
      minX: Infinity, maxX: -Infinity,
      minY: Infinity, maxY: -Infinity,
      minZ: Infinity, maxZ: -Infinity
    };
    
    for (let w = 0; w < WAVE_COUNT; w++) {
      const particles = new THREE.BufferGeometry();
      const particlePositions = new Float32Array(PARTICLES_PER_WAVE * 3);
      const particleColors = new Float32Array(PARTICLES_PER_WAVE * 3);
      const originalPositions = new Float32Array(PARTICLES_PER_WAVE * 3);
      const particleSizes = new Float32Array(PARTICLES_PER_WAVE);
      
      // Wave parameters - using different wave types for variety
      const waveHeight = 5 + w * 2.5; // Taller waves with more dramatic peaks
      const waveOffset = 0; // All waves share the same base offset
      
      // Balance the wave distribution across the entire width
      // Slightly increase the grid width for more even distribution
      const gridWidth = Math.sqrt(PARTICLES_PER_WAVE * 4.2);
      
      // Ensure symmetric wave patterns by using consistent wave types
      // Select different wave equations for each wave to create varied but smooth patterns
      let waveType = w % 3; // 0, 1, or 2 - different wave patterns
      
      console.log(`Creating Wave ${w}:`, {
        waveHeight,
        waveType,
        gridWidth,
        particleCount: PARTICLES_PER_WAVE
      });
      
      // Create cylindrical distribution around wave paths instead of flat bands
      for (let i = 0; i < PARTICLES_PER_WAVE; i++) {
        // Create a grid-like distribution pattern for particles
        const gridX = i % gridWidth;
        const gridZ = Math.floor(i / gridWidth);
        
        // Map coordinates to span exact screen width with slight padding to go beyond edges
        // This ensures wave endpoints are just beyond screen edges
        let screenPosition = (gridX / gridWidth) * 2 - 1; // Range from -1 to 1
        
        // ENDPOINT ENHANCEMENT: Create denser clusters of particles at the endpoints
        // Apply a subtle power curve to push more particles toward the edges
        const edgeClusteringFactor = 1.15; // Controls how much particles cluster at edges
        screenPosition = Math.sign(screenPosition) * Math.pow(Math.abs(screenPosition), edgeClusteringFactor);
        
        // CORRECTED POSITIONING: Apply correction to ensure true centering in the viewport
        // Directly map to the screen width, scaling to ensure waves reach the viewport edges
        const scaleFactor = 1.0; // Makes waves reach the viewport edges
        const x = screenPosition * (visibleWidthAtZDepth / 2) * scaleFactor;
        
        // Create cylindrical distribution around the wave path
        // Generate angle around the wave path (0 to 2π)
        const angle = Math.random() * Math.PI * 2;
        
        // Generate distance from center path (with more particles closer to center)
        // Adjust the distance based on screen orientation for optimal density
        // ENDPOINT ENHANCEMENT: Reduce radius at endpoints to create tighter clusters
        const edgeProximity = Math.pow(Math.abs(screenPosition), 2); // 0 at center, 1 at edges
        const radiusMultiplier = (isLandscape ? 0.65 : 0.55) * (1.0 - (edgeProximity * 0.3)); // Reduce radius up to 30% at edges
        const distance = Math.pow(Math.random(), 3) * 2.0 * radiusMultiplier + (w * 0.3);
        
        // Convert polar to cartesian coordinates around the wave path
        const yVariation = Math.sin(angle) * distance;
        const zVariation = Math.cos(angle) * distance;
        
        // Initialize with cylindrical dispersed positions
        const y = commonStartY + yVariation;
        const z = zVariation;
        
        particlePositions[i * 3] = x;
        particlePositions[i * 3 + 1] = y;
        particlePositions[i * 3 + 2] = z;
        
        // Track extreme positions for debugging
        waveParticleRanges.minX = Math.min(waveParticleRanges.minX, x);
        waveParticleRanges.maxX = Math.max(waveParticleRanges.maxX, x);
        waveParticleRanges.minY = Math.min(waveParticleRanges.minY, y);
        waveParticleRanges.maxY = Math.max(waveParticleRanges.maxY, y);
        waveParticleRanges.minZ = Math.min(waveParticleRanges.minZ, z);
        waveParticleRanges.maxZ = Math.max(waveParticleRanges.maxZ, z);
        
        // For every 1000th particle, log detailed position info
        if (i % 1000 === 0) {
          console.log(`Wave ${w} Particle ${i} Position:`, {
            screenPosition,
            calculatedWidth,
            scaleFactor,
            x,
            y,
            z,
            radiusMultiplier,
            distance
          });
        }
        
        // Store original positions and cylindrical coordinates
        originalPositions[i * 3] = x;
        originalPositions[i * 3 + 1] = y; // Store the actual y position with offset
        originalPositions[i * 3 + 2] = z; // Store the actual z position
        
        // Create color gradient across the wave width
        // Use normalized position for color calculation (-1 to 1, then 0 to 1)
        const normalizedPos = (x / (calculatedWidth / 2)); // Range from -1 to 1
        const colorPosition = (normalizedPos + 1) / 2; // Convert to 0-1 range
        
        // Apply smooth color interpolation with expanded color regions
        let color;
        // Adjust transition points to reduce white dominance
        // Left side gets more space (0-0.45), center smaller (0.45-0.55), right side more space (0.55-1)
        if (colorPosition < 0.45) {
          // Left half - interpolate between left color and center color
          const t = colorPosition / 0.45; // 0 to 1 within left portion
          const easedT = Math.pow(t, 1.0); // Reduced easing for more gradual transition
          color = lerpColor(leftColor, centerColor, easedT);
          
          // Add subtle variation to avoid perfectly smooth gradient
          if (Math.random() < 0.3) {
            const randomVariation = Math.random() * 0.12;
            color.offsetHSL(0, 0, randomVariation - 0.06);
          }
        } else if (colorPosition > 0.55) {
          // Right half - interpolate between center color and right color
          const t = (colorPosition - 0.55) / 0.45; // 0 to 1 within right portion
          const easedT = Math.pow(t, 1.0); // Reduced easing for more gradual transition
          color = lerpColor(centerColor, rightColor, easedT);
          
          // Add subtle variation to avoid perfectly smooth gradient
          if (Math.random() < 0.3) {
            const randomVariation = Math.random() * 0.12;
            color.offsetHSL(0, 0, randomVariation - 0.06);
          }
        } else {
          // Center portion - narrower band
          const t = (colorPosition - 0.45) / 0.1; // 0 to 1 within center band
          color = lerpColor(centerColor, centerColor, t); // Center color with slight variations
          
          // Add more variation to center to blend better with sides
          if (Math.random() < 0.5) {
            const randomVariation = Math.random() * 0.15;
            if (colorPosition < 0.5) {
              // Bias slightly toward left color in left half of center
              color.offsetHSL(-0.05, 0.1, randomVariation - 0.08);
            } else {
              // Bias slightly toward right color in right half of center
              color.offsetHSL(0.05, 0.1, randomVariation - 0.08);
            }
          }
        }
        
        particleColors[i * 3] = color.r;
        particleColors[i * 3 + 1] = color.g;
        particleColors[i * 3 + 2] = color.b;
        
        // Variable sizes for particles
        particleSizes[i] = 0.4 + Math.random() * 0.7;
      }
      
      // Log summary of wave particle positions
      console.log(`Wave ${w} Position Summary:`, {
        xRange: [waveParticleRanges.minX, waveParticleRanges.maxX],
        yRange: [waveParticleRanges.minY, waveParticleRanges.maxY],
        zRange: [waveParticleRanges.minZ, waveParticleRanges.maxZ],
        visibleWidthAtZDepth: visibleWidthAtZDepth,
        calculatedWidth: calculatedWidth,
      });
      
      particles.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
      particles.setAttribute('customColor', new THREE.BufferAttribute(particleColors, 3));
      particles.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
      
      // Custom shader material that renders each particle as a glowing point
      const particleMaterial = new THREE.ShaderMaterial({
        uniforms: {
          pointTexture: { value: createParticleTexture() }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 customColor;
          varying vec3 vColor;
          
          void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: theme === 'light' 
          ? `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
              vec4 texColor = texture2D(pointTexture, gl_PointCoord);
              if (texColor.a < 0.1) discard;
              gl_FragColor = vec4(vColor, 1.0) * texColor;
            }
          `
          : `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
              gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
              if (gl_FragColor.a < 0.1) discard;
            }
          `,
        blending: theme === 'light' ? THREE.NormalBlending : THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 1.0, // Use full opacity and let the texture control transparency
        vertexColors: true,
        depthWrite: false, // Prevent z-fighting with transparent objects
        alphaTest: theme === 'light' ? 0.1 : 0.01 // Higher alpha test threshold for light mode
      });
      
      const particleSystem = new THREE.Points(particles, particleMaterial);
      particleSystem.userData = {
        originalPositions,
        waveOffset,
        waveHeight,
        baseWaveHeight: waveHeight, // Store base height for fluctuation
        minWaveHeight: waveHeight * 0.6, // Minimum height threshold to prevent flat waves
        speed: 0.5 + Math.random() * 0.5,
        frequency: 0.02 + Math.random() * 0.02,
        baseFrequency: 0.02 + Math.random() * 0.02, // Store base frequency for fluctuation
        minFrequency: 0.015, // Minimum frequency to prevent straight lines
        amplitudeFluctuation: 0.2 + Math.random() * 0.6, // How much amplitude changes (reduced for smoother waves)
        frequencyFluctuation: 0.3 + Math.random() * 0.3, // How much frequency changes (reduced for smoother waves)
        fluctuationSpeed: 0.15 + Math.random() * 0.25, // Speed of fluctuation (slower for smoother waves)
        timeOffset: Math.random() * Math.PI * 2, // Random phase for fluctuation
        waveType: waveType, // Store the wave type
        initialDistances: new Float32Array(PARTICLES_PER_WAVE), // Array for cylindrical distances
        initialAngles: new Float32Array(PARTICLES_PER_WAVE) // Array for cylindrical angles
      };
      
      // Store particle-specific information
      for (let i = 0; i < PARTICLES_PER_WAVE; i++) {
        // Generate distance and angle for cylindrical distribution
        const angle = Math.random() * Math.PI * 2;
        // Make the wave more condensed - optimize for standard zoom level
        const distance = Math.pow(Math.random(), 3) * 1.6 + (w * 0.25);
        
        // Store size and position information
        particleSystem.userData.initialDistances[i] = distance;
        particleSystem.userData.initialAngles[i] = angle;
      }
      
      wavesContainer.add(particleSystem);
      waves.push(particleSystem);
    }
    
    // Log overall position ranges for all wave particles
    console.log('All Wave Particles Position Range:', waveParticleRanges);
    console.log('Comparison to viewport:', {
      xRangeVsVisibleWidth: [
        waveParticleRanges.minX / (visibleWidthAtZDepth / 2), 
        waveParticleRanges.maxX / (visibleWidthAtZDepth / 2)
      ],
      yRangeVsVisibleHeight: [
        waveParticleRanges.minY / (visibleHeightAtZDepth / 2),
        waveParticleRanges.maxY / (visibleHeightAtZDepth / 2)
      ]
    });
    
    // Apply immediate constraints to wave particles to ensure they start within bounds
    console.log('Applying initial constraints to wave particles...');
    waves.forEach((wave, index) => {
      const constrained = constrainParticlePosition(wave, visibleWidthAtZDepth, visibleHeightAtZDepth);
      console.log(`Wave ${index} initial constraint applied: ${constrained}`);
    });
    
    // Adjust the position of the waves container to center on screen
    wavesContainer.position.set(0, 0, 0);
    
    // Add background particles
    let backgroundParticleSystem;
    
    // Create background particles with variable sizes
    if (BACKGROUND_PARTICLE_COUNT > 0) {
      const bgParticles = new THREE.BufferGeometry();
      const bgPositions = new Float32Array(BACKGROUND_PARTICLE_COUNT * 3);
      const bgColors = new Float32Array(BACKGROUND_PARTICLE_COUNT * 3);
      const bgSizes = new Float32Array(BACKGROUND_PARTICLE_COUNT);
      
      // Tracking for background particle positions
      let bgParticleRanges = {
        minX: Infinity, maxX: -Infinity,
        minY: Infinity, maxY: -Infinity,
        minZ: Infinity, maxZ: -Infinity
      };
      
      console.log('Creating background particles:', {
        count: BACKGROUND_PARTICLE_COUNT,
        visibleWidthAtZDepth,
        visibleHeightAtZDepth
      });
      
      // Create randomly distributed background particles
      for (let i = 0; i < BACKGROUND_PARTICLE_COUNT; i++) {
        // Random position throughout the scene with adaptive distribution
        // Adjust spread based on device orientation
        const spreadFactor = isLandscape ? 0.9 : 0.8; // Increased from 0.85/0.75 to match wave particle expansion
        
        // CORRECTED POSITIONING: Use direct viewport mapping for better centering
        // Apply consistent scaling approach for background particles
        const bgScaleFactor = 1.0; // Increased from 0.9 to match wave particle scaling
        
        // ENDPOINT ENHANCEMENT: Add a chance to place background particles near the edges
        let positionBias = Math.random() * 2 - 1; // Original range from -1 to 1
        // For 15% of particles, bias them toward the edges
        if (Math.random() < 0.15) {
          // Create bias toward either left or right edge
          const edgeSide = Math.random() < 0.5 ? -1 : 1;
          // Position close to the edge with some variation (0.85 to 1.0 of max distance)
          positionBias = edgeSide * (0.85 + Math.random() * 0.15);
        }
        
        // Ensure particles fill the visible area properly regardless of aspect ratio
        const x = positionBias * (visibleWidthAtZDepth / 2) * spreadFactor * bgScaleFactor;
        const y = (Math.random() * 2 - 1) * (visibleHeightAtZDepth / 2) * spreadFactor;
        const z = (Math.random() * 2 - 1) * 35; // Keep existing value
        
        bgPositions[i * 3] = x;
        bgPositions[i * 3 + 1] = y;
        bgPositions[i * 3 + 2] = z;
        
        // Track extreme positions for debugging
        bgParticleRanges.minX = Math.min(bgParticleRanges.minX, x);
        bgParticleRanges.maxX = Math.max(bgParticleRanges.maxX, x);
        bgParticleRanges.minY = Math.min(bgParticleRanges.minY, y);
        bgParticleRanges.maxY = Math.max(bgParticleRanges.maxY, y);
        bgParticleRanges.minZ = Math.min(bgParticleRanges.minZ, z);
        bgParticleRanges.maxZ = Math.max(bgParticleRanges.maxZ, z);
        
        // For select particles, log detailed position info
        if (i % 1000 === 0) {
          console.log(`Background Particle ${i} Position:`, {
            x,
            y,
            z,
            spreadFactor,
            bgScaleFactor,
            calculatedWidth,
            visibleHeightAtZDepth
          });
        }
        
        // Variable sizes - some larger particles like in image 2
        bgSizes[i] = Math.random() < 0.05 ? // 5% of particles are larger
                      0.8 + Math.random() * 1.2 : // Large particles
                      0.1 + Math.random() * 0.4;  // Normal small particles
        
        // Color based on position - similar to wave colors
        // Use normalized position for color calculation
        const normalizedBgX = (x / (calculatedWidth / 2 * spreadFactor)); // Range from -1 to 1
        const bgColorPosition = (normalizedBgX + 1) / 2; // Convert to 0-1 range
        
        // Apply the same smooth color interpolation as wave particles
        let color;
        if (bgColorPosition < 0.45) {
          // Left half - interpolate between left color and center color
          const t = bgColorPosition / 0.45; // 0 to 1 within left half
          // Add slightly more variation to background particles
          const easedT = Math.pow(t, 1.1); // Reduced easing for more gradual transition
          color = lerpColor(leftColor, centerColor, easedT);
          
          // Add variation for more natural look
          if (Math.random() < 0.3) { // Increased chance of variation
            const randomVariation = Math.random() * 0.15; // Slightly more variation
            color.offsetHSL(0, 0, randomVariation - 0.07);
          }
        } else if (bgColorPosition > 0.55) {
          // Right half - interpolate between center color and right color
          const t = (bgColorPosition - 0.55) / 0.45; // 0 to 1 within right half
          const easedT = Math.pow(t, 1.1); // Reduced easing for more gradual transition
          color = lerpColor(centerColor, rightColor, easedT);
          
          // Add variation for more natural look
          if (Math.random() < 0.3) { // Increased chance of variation
            const randomVariation = Math.random() * 0.15; // Slightly more variation
            color.offsetHSL(0, 0, randomVariation - 0.07);
          }
        } else {
          // Center portion - narrower band
          const t = (bgColorPosition - 0.45) / 0.1; // 0 to 1 within center band
          color = lerpColor(centerColor, centerColor, t); // Center color with slight variations
          
          // Add more variation to center to blend better with sides
          if (Math.random() < 0.5) {
            const randomVariation = Math.random() * 0.15;
            if (bgColorPosition < 0.5) {
              // Bias slightly toward left color in left half of center
              color.offsetHSL(-0.05, 0.1, randomVariation - 0.08);
            } else {
              // Bias slightly toward right color in right half of center
              color.offsetHSL(0.05, 0.1, randomVariation - 0.08);
            }
          }
        }
        
        // Make some background particles brighter/dimmer for depth effect
        if (Math.random() < 0.1) {
          if (Math.random() < 0.5) {
            // Make some particles brighter
            color.offsetHSL(0, 0, 0.1);
          } else {
            // Make some particles dimmer
            color.offsetHSL(0, 0, -0.15);
          }
        }
        
        bgColors[i * 3] = color.r;
        bgColors[i * 3 + 1] = color.g;
        bgColors[i * 3 + 2] = color.b;
      }
      
      // Log summary of background particle positions
      console.log('Background Particles Position Summary:', bgParticleRanges);
      console.log('Background vs Viewport Comparison:', {
        xRangeVsVisibleWidth: [
          bgParticleRanges.minX / (visibleWidthAtZDepth / 2), 
          bgParticleRanges.maxX / (visibleWidthAtZDepth / 2)
        ],
        yRangeVsVisibleHeight: [
          bgParticleRanges.minY / (visibleHeightAtZDepth / 2),
          bgParticleRanges.maxY / (visibleHeightAtZDepth / 2)
        ]
      });
      
      bgParticles.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
      bgParticles.setAttribute('customColor', new THREE.BufferAttribute(bgColors, 3));
      bgParticles.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
      
      // Custom shader for variable sizes
      const bgMaterial = new THREE.ShaderMaterial({
        uniforms: {
          pointTexture: { value: createParticleTexture() }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 customColor;
          varying vec3 vColor;
          
          void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: theme === 'light' 
          ? `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
              vec4 texColor = texture2D(pointTexture, gl_PointCoord);
              if (texColor.a < 0.1) discard;
              gl_FragColor = vec4(vColor, 1.0) * texColor;
            }
          `
          : `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
              gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
              if (gl_FragColor.a < 0.1) discard;
            }
          `,
        blending: theme === 'light' ? THREE.NormalBlending : THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 1.0, // Use full opacity and let the texture control transparency
        vertexColors: true,
        depthWrite: false, // Prevent z-fighting with transparent objects
        alphaTest: theme === 'light' ? 0.1 : 0.01 // Higher alpha test threshold for light mode
      });
      
      backgroundParticleSystem = new THREE.Points(bgParticles, bgMaterial);
      // CRITICAL FIX: Add background particles directly to the scene, not to the scene container
      // This ensures they're positioned relative to the global origin
      scene.add(backgroundParticleSystem);
      
      // Store initial positions for reset during fullscreen toggle
      if (backgroundParticleSystem.geometry) {
        const positions = backgroundParticleSystem.geometry.attributes.position.array;
        const initialPositions = new Float32Array(positions.length);
        
        // Create a deep copy of the initial positions
        for (let i = 0; i < positions.length; i++) {
          initialPositions[i] = positions[i];
        }
        
        // Store in userData for later access during resize
        backgroundParticleSystem.userData.initialPositions = initialPositions;
        console.log('Stored initial background particle positions for future reset');
      }
    }
    
    // Apply immediate constraints to background particles to ensure they start within bounds
    console.log('Applying initial constraints to background particles...');
    if (backgroundParticleSystem) {
      const constrained = constrainParticlePosition(backgroundParticleSystem, visibleWidthAtZDepth * 1.2, visibleHeightAtZDepth * 1.2);
      console.log(`Background particles initial constraint applied: ${constrained}`);
    }
    
    // Create more intense glowing particle texture similar to the reference image
    function createParticleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      
      const context = canvas.getContext('2d');
      if (!context) {
        console.error('Could not get 2D context for particle texture');
        return new THREE.Texture();
      }
      
      // Clear the canvas first with a fully transparent background
      context.clearRect(0, 0, 64, 64);
      
      const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
      
      // Adjust gradient based on theme
      if (theme === 'light') {
        // For light theme, use darker blues with stronger opacity for visibility on white
        gradient.addColorStop(0, 'rgba(10, 80, 255, 1.0)');    // Even deeper blue center
        gradient.addColorStop(0.1, 'rgba(20, 100, 255, 0.95)');
        gradient.addColorStop(0.25, 'rgba(40, 120, 255, 0.9)');
        gradient.addColorStop(0.5, 'rgba(60, 140, 255, 0.8)');
        gradient.addColorStop(0.75, 'rgba(80, 160, 255, 0.6)');
        gradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
      } else {
        // Original gradient for dark theme
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.95)');
        gradient.addColorStop(0.25, 'rgba(240, 250, 255, 0.9)');
        gradient.addColorStop(0.5, 'rgba(200, 230, 255, 0.6)');
        gradient.addColorStop(0.75, 'rgba(150, 200, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
      }
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 64, 64);
      
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      texture.premultiplyAlpha = false; // Disable premultiplied alpha for better transparency
      return texture;
    }
    
    // Mouse interaction - improved for better accuracy
    const raycaster = new THREE.Raycaster();
    const screenMouse = new THREE.Vector2();
    
    // Create a plane for better mouse interaction at z=0
    const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    
    const handleMouseMove = (event) => {
      // Get the bounding rectangle of the actual renderer canvas
      const rect = renderer.domElement.getBoundingClientRect();
      
      // Ensure the event is within the container bounds
      if (
        event.clientX < rect.left ||
        event.clientX > rect.right ||
        event.clientY < rect.top ||
        event.clientY > rect.bottom
      ) {
        // Mouse is outside the canvas - set to far away
        mouseRef.current.set(999, 999, 0);
        return;
      }
      
      // Calculate mouse position in normalized device coordinates (-1 to +1)
      screenMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      screenMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      // Log mouse coordinates occasionally for debugging
      if (Math.random() < 0.001) {
        console.log('Mouse move detected:', {
          clientX: event.clientX,
          clientY: event.clientY,
          canvasRect: {
            left: rect.left,
            top: rect.top,
            width: rect.width,
            height: rect.height
          },
          normalizedCoords: {
            x: screenMouse.x,
            y: screenMouse.y
          }
        });
      }
      
      // Update raycaster with camera and mouse position
      raycaster.setFromCamera(screenMouse, camera);
      
      // Find intersection with the plane
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(interactionPlane, intersectPoint);
      
      // Update mouse position reference
      mouseRef.current.copy(intersectPoint);
    };
    
    // Set mouse to far away when it leaves the canvas
    const handleMouseLeave = () => {
      console.log('Mouse leave event detected');
      mouseRef.current.set(999, 999, 0);
    };
    
    // Update background particles in the animation loop
    const animateBackgroundParticles = (time) => {
      // Only animate if background particles exist
      if (backgroundParticleSystem && backgroundParticleSystem.geometry) {
        const bgPositions = backgroundParticleSystem.geometry.attributes.position.array;
        
        // Define tighter bounds for background particles
        const maxBgX = visibleWidthAtZDepth * 0.48; // Increased from 0.45 to match main constraints
        const maxBgY = visibleHeightAtZDepth * 0.48; // Increased from 0.45 to match main constraints
        const maxBgZ = 35; // Increased from 25 for better depth
        
        // Subtle movement for background particles
        for (let i = 0; i < BACKGROUND_PARTICLE_COUNT; i++) {
          const ix = i * 3;
          
          // More natural, varied floating motion
          const uniqueOffsetY = i * 0.015;
          const uniqueOffsetX = i * 0.012;
          const uniqueSpeedY = 0.3 + Math.sin(i * 0.1) * 0.2;
          const uniqueSpeedX = 0.2 + Math.cos(i * 0.1) * 0.15;
          
          // Apply motion
          bgPositions[ix + 1] += Math.sin(time * uniqueSpeedY + uniqueOffsetY) * 0.015;
          bgPositions[ix] += Math.cos(time * uniqueSpeedX + uniqueOffsetX) * 0.01;
          bgPositions[ix + 2] += Math.sin(time * 0.2 + i * 0.02) * 0.005;
          
          // Instead of wrapping, enforce bounds - keep particles within the visible area
          if (Math.abs(bgPositions[ix]) > maxBgX) {
            // Bounce back from the edges for x
            bgPositions[ix] = Math.sign(bgPositions[ix]) * (maxBgX - Math.random() * 3);
          }
          
          if (Math.abs(bgPositions[ix + 1]) > maxBgY) {
            // Bounce back from the edges for y
            bgPositions[ix + 1] = Math.sign(bgPositions[ix + 1]) * (maxBgY - Math.random() * 3);
          }
          
          if (Math.abs(bgPositions[ix + 2]) > maxBgZ) {
            // Bounce back from the edges for z
            bgPositions[ix + 2] = Math.sign(bgPositions[ix + 2]) * (maxBgZ - Math.random() * 3);
          }
        }
        
        backgroundParticleSystem.geometry.attributes.position.needsUpdate = true;
      }
    };
    
    // Add a debug function to verify scene is properly centered
    const verifySceneCentering = () => {
      // Calculate the current center of all wave particles in world space
      let centerX = 0, centerY = 0, centerZ = 0;
      let totalPoints = 0;
      
      waves.forEach(wave => {
        const positions = wave.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          centerX += positions[i];
          centerY += positions[i + 1];
          centerZ += positions[i + 2];
          totalPoints++;
        }
      });
      
      if (totalPoints > 0) {
        centerX /= totalPoints;
        centerY /= totalPoints;
        centerZ /= totalPoints;
      }
      
      console.log('Calculated wave center point:', { centerX, centerY, centerZ });
      
      // Update debug visual if enabled
      if (debugCenter && debugCenter.visible) {
        debugCenter.position.set(centerX, centerY, centerZ);
      }
      
      return { centerX, centerY, centerZ };
    };
    
    // Run initial center verification after setup
    setTimeout(() => {
      verifySceneCentering();
    }, 1000);
    
    // Animation loop
    const animate = () => {
      const time = Date.now() * 0.001;
      
      // Only log rendering debug info periodically to avoid console spam
      const shouldLogRenderInfo = Math.floor(time) % 10 === 0 && Math.floor(time) !== lastLogTime;
      
      // Every 5 seconds, log position data to help debug bounds issues
      if (Math.floor(time) % 5 === 0 && Math.floor(time) !== lastLogTime) {
        logPositionData(scene, camera, waves, backgroundParticleSystem, visibleWidthAtZDepth, visibleHeightAtZDepth, calculatedWidth);
        lastLogTime = Math.floor(time);
      }
      
      // Update wave modulation
      waves.forEach((wave) => {
        const positions = wave.geometry.attributes.position.array;
        const originalPositions = wave.userData.originalPositions;
        const baseWaveHeight = wave.userData.baseWaveHeight;
        const waveOffset = wave.userData.waveOffset;
        const speed = wave.userData.speed;
        const baseFrequency = wave.userData.baseFrequency;
        const waveType = wave.userData.waveType;
        
        // Calculate fluctuating amplitude and frequency - more subtle now
        const timeWithOffset = time + wave.userData.timeOffset;
        const amplitudeFluctuation = Math.sin(timeWithOffset * wave.userData.fluctuationSpeed) * wave.userData.amplitudeFluctuation;
        const frequencyFluctuation = Math.cos(timeWithOffset * wave.userData.fluctuationSpeed * 0.7) * wave.userData.frequencyFluctuation;
        
        // Apply fluctuations with minimum threshold to prevent flat waves
        const calculatedHeight = baseWaveHeight * (1 + amplitudeFluctuation * 0.6); // Reduced fluctuation
        // Ensure wave height never falls below minimum threshold
        const currentWaveHeight = Math.max(calculatedHeight, wave.userData.minWaveHeight);
        
        // Ensure frequency never falls below minimum (prevents straight lines)
        const calculatedFrequency = baseFrequency * (1 + frequencyFluctuation * 0.15); // Reduced fluctuation
        const currentFrequency = Math.max(calculatedFrequency, wave.userData.minFrequency);
        
        // Apply a zoom correction to frequency for better appearance at 100% zoom 
        const zoomFrequencyCorrection = isLandscape ? 1.0 : 0.95;
        const zoomAdjustedFrequency = currentFrequency * zoomFrequencyCorrection;
        
        // Update wave properties for animation
        wave.userData.waveHeight = currentWaveHeight;
        wave.userData.frequency = zoomAdjustedFrequency;
        
        for (let i = 0; i < positions.length / 3; i++) {
          const ix = i * 3;
          const x = originalPositions[ix];
          
          // Generate different smooth wave patterns based on wave type
          let primaryWave, secondaryWave;
          
          // Create a smooth amplitude falloff that preserves the wave shape
          // Using normalized position for consistent tapering
          const normalizedDistanceFromCenter = Math.abs(x / (calculatedWidth / 2));
          // Ensure perfectly symmetric tapering on both sides
          const smoothTaperingFactor = Math.cos(normalizedDistanceFromCenter * Math.PI * 0.5);
          
          // Ensure the tapering factor never makes the wave too flat
          // Increase minimum tapering to 0.2 for more consistent wave heights at edges
          const minTapering = 0.2;
          // ENDPOINT ENHANCEMENT: Reduce animation amplitude at edges to keep clusters intact
          // This helps maintain the endpoint clusters during animation
          const edgeProximityFactor = Math.pow(normalizedDistanceFromCenter, 3); // Stronger effect at edges
          const edgeStabilization = 1.0 - (edgeProximityFactor * 0.5); // Reduce movement up to 50% at edges
          const adjustedTaperingFactor = minTapering + smoothTaperingFactor * (1 - minTapering) * edgeStabilization;
                
          // Calculate wavelength adjusted to screen width for consistent wave count
          // This ensures similar number of wave crests regardless of screen size
          const wavelengthAdjustment = isLandscape ? 1.0 : 0.85; // Adjusted wavelength for portrait mode
          const adjustedFrequency = currentFrequency * wavelengthAdjustment;
          
          // Different wave equations for variety, adapted to screen dimensions
          switch(waveType) {
            case 0:
              // Standard sine wave with symmetrical behavior - ensure perfect symmetry
              // Add absolute phase offset to ensure identical behavior on both sides
              primaryWave = Math.sin((x * adjustedFrequency) + (Math.PI/2) + time * speed) * currentWaveHeight * adjustedTaperingFactor;
              // Match secondary wave amplitude to primary to ensure balanced movement
              secondaryWave = Math.sin((x * adjustedFrequency * 2.8) + (Math.PI/2) + time * speed * 0.7) * (currentWaveHeight * 0.22) * adjustedTaperingFactor;
              break;
            case 1:
              // Sine + cosine composite with enhanced symmetry
              // Use consistent wave behavior regardless of position
              primaryWave = Math.sin((x * adjustedFrequency) + (Math.PI/2) + time * speed) * currentWaveHeight * adjustedTaperingFactor;
              // Simplify secondary wave for better symmetry
              secondaryWave = Math.sin((x * adjustedFrequency * 2) + (Math.PI/2) + time * speed * 1.3) * (currentWaveHeight * 0.3) * adjustedTaperingFactor;
              break;
            case 2:
              // Ensure both sides have the same wave behavior
              primaryWave = Math.sin((x * adjustedFrequency) + (Math.PI/2) + time * speed) * currentWaveHeight * adjustedTaperingFactor;
              secondaryWave = Math.sin((x * adjustedFrequency * 1.5) + (Math.PI/2) + time * speed * 0.5) * (currentWaveHeight * 0.4) * adjustedTaperingFactor;
              break;
            default:
              // Fallback
              primaryWave = Math.sin(x * currentFrequency + time * speed) * currentWaveHeight * adjustedTaperingFactor;
              secondaryWave = 0;
          }
          
          // Combine waves for a final smooth pattern
          const baseY = waveOffset + primaryWave + secondaryWave;
          
          // Calculate ideal position on the wave
          const idealY = baseY;
          
          // Get the initial distance and angle for this particle from userData
          const initialDistance = wave.userData.initialDistances[i];
          const initialAngle = wave.userData.initialAngles[i];
          
          // Reconstruct the ideal cylindrical position around the wave
          const idealCylindricalY = idealY + Math.sin(initialAngle) * initialDistance;
          const idealCylindricalZ = Math.cos(initialAngle) * initialDistance;
          
          // Current position
          const currentY = positions[ix + 1];
          const currentZ = positions[ix + 2];
          
          // Calculate how far the particle is from its ideal position
          const deltaY = idealCylindricalY - currentY;
          const deltaZ = idealCylindricalZ - currentZ;
          const distanceFromIdeal = Math.sqrt(deltaY * deltaY + deltaZ * deltaZ);
          
          // Stronger return force when farther from ideal position
          // This creates a spring-like effect - increased strength for more responsive return
          const returnStrength = Math.min(1, distanceFromIdeal * 0.15);
          
          // Apply return force - stronger the further away
          let y = currentY + deltaY * returnStrength * 0.12;
          let z = currentZ + deltaZ * returnStrength * 0.12;
          
          // Mouse interaction - particles disperse near mouse position
          // Adjusted influence radius based on screen dimensions for consistent interaction
          const mouseInfluenceBase = 7; // Further reduced radius for more precise interaction
          const mouseInfluence = (mouseInfluenceBase / waveScale) * (isLandscape ? 0.85 : 0.7); 
          const mouseStrength = 10 * (isLandscape ? 0.85 : 1.0); // Adjusted strength for better feel
          
          // Handle mouse interaction in the scaled space
          if (mouseRef.current.x !== 999) {
            // Calculate distance to mouse in x-y plane
            const dx = x - mouseRef.current.x;
            const dy = y - mouseRef.current.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < mouseInfluence) {
              // Disperse particles away from mouse
              const angle = Math.atan2(dy, dx);
              const force = (1 - distance / mouseInfluence) * mouseStrength;
              
              // Add randomized dispersion with smoother falloff
              const falloff = Math.pow(1 - distance / mouseInfluence, 2);
              y += Math.sin(angle) * force * falloff * (0.5 + Math.random() * 0.5);
              z += (Math.random() - 0.5) * force * falloff * 2;
            }
          }
          
          // Apply immediate position constraints to prevent particles from getting too far
          const maxAllowedX = visibleWidthAtZDepth * 0.5;
          const maxAllowedY = visibleHeightAtZDepth * 0.5;
          const maxAllowedZ = 40;
          
          // Constrain X position (not needed since x is not modified in animation)
          
          // Constrain Y position
          if (Math.abs(y) > maxAllowedY) {
            y = Math.sign(y) * (maxAllowedY - 1 - Math.random() * 2);
          }
          
          // Constrain Z position
          if (Math.abs(z) > maxAllowedZ) {
            z = Math.sign(z) * (maxAllowedZ - 1 - Math.random() * 2);
          }
          
          positions[ix + 1] = y;
          positions[ix + 2] = z;
        }
        
        wave.geometry.attributes.position.needsUpdate = true;
      });
      
      // Animate background particles
      animateBackgroundParticles(time);
      
      // Check and constrain particle positions within viewport more frequently
      // Run the constraint check every 10 frames instead of relying on random chance
      if (Math.floor(time * 60) % 10 === 0) {
        let anyConstrained = false;
        waves.forEach(wave => {
          if (constrainParticlePosition(wave, visibleWidthAtZDepth, visibleHeightAtZDepth)) {
            anyConstrained = true;
          }
        });
        
        // Also constrain background particles
        if (backgroundParticleSystem) {
          if (constrainParticlePosition(backgroundParticleSystem, visibleWidthAtZDepth * 1.1, visibleHeightAtZDepth * 1.1)) {
            anyConstrained = true;
          }
        }
        
        // Log when particles needed constraining (but limit to avoid console spam)
        if (anyConstrained && Math.random() < 0.1) {
          console.log(`[${time.toFixed(2)}] Particles constrained to stay within bounds`);
        }
      }
      
      // For light mode, use a completely different rendering approach - skip the post-processing entirely
      if (theme === 'light') {
        if (shouldLogRenderInfo) {
          console.log(`DEBUG: Light mode direct rendering at time ${time.toFixed(2)}`);
        }
        
        // Clear with the correct background color first
        renderer.setClearColor(0xffffff, 1);
        renderer.clear(true, true, true);
        
        // ONLY use direct rendering for light mode, skipping post-processing entirely
        // This should bypass any issues with the composer or bloom pass
        renderer.render(scene, camera);
      } else {
        if (shouldLogRenderInfo) {
          console.log(`DEBUG: Dark mode post-processed rendering at time ${time.toFixed(2)}`);
        }
        // Use standard composer rendering for dark mode
        composer.render();
      }
      
      // Continue animation loop
      requestAnimationFrame(animate);
    };
    
    // Track when we last logged to avoid spam
    let lastLogTime = 0;
    
    // Handle window resize
    const handleResize = () => {
      if (!mountRef.current) return;
      
      const newWidth = mountRef.current.clientWidth;
      const newHeight = mountRef.current.clientHeight;
      
      // Prevent resize to zero dimensions
      if (newWidth === 0 || newHeight === 0) return;
      
      console.log('Window resize detected:', { newWidth, newHeight });
      
      // Check for fullscreen toggle by comparing aspect ratios
      const prevAspectRatio = camera.aspect;
      const newAspectRatio = newWidth / newHeight;
      const isFullscreenToggle = Math.abs(prevAspectRatio - newAspectRatio) > 0.1;
      
      if (isFullscreenToggle) {
        console.log('Fullscreen toggle detected - applying complete particle reset');
      }
      
      // Update camera aspect and projection
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      
      // Recalculate visible dimensions for responsive layout
      const newIsLandscape = newAspectRatio > 1;
      
      // Calculate visible dimensions at z=0 with the updated aspect ratio
      const fovRadians = camera.fov * Math.PI / 180;
      const newVisibleHeightAtZDepth = 2 * Math.tan(fovRadians / 2) * cameraDistance;
      // Apply the same correction factor to ensure viewport calculations remain accurate at 100% zoom
      const newVisibleWidthAtZDepth = newVisibleHeightAtZDepth * camera.aspect * viewportCorrectionFactor;
      
      console.log('Resize: new calculated dimensions:', {
        newVisibleWidthAtZDepth,
        newVisibleHeightAtZDepth,
        newAspectRatio,
        newIsLandscape,
        viewportCorrectionFactor,
        previousVisibleWidthAtZDepth: visibleWidthAtZDepth,
        previousVisibleHeightAtZDepth: visibleHeightAtZDepth
      });
      
      // IMPORTANT: Update viewport markers after resize to confirm boundaries are correct
      // Remove existing markers if present
      scene.children.forEach(child => {
        if (child.isMesh && ['leftMarker', 'rightMarker', 'originMarker'].includes(child.name)) {
          scene.remove(child);
        }
        if (child.isLine && child.name === 'centerLine') {
          scene.remove(child);
        }
      });
      
      // Add updated boundary markers
      const markerGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      
      // Left edge marker (red)
      const leftMarker = new THREE.Mesh(
        markerGeometry,
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      leftMarker.position.set(-newVisibleWidthAtZDepth/2, 0, 0);
      leftMarker.name = 'leftMarker';
      leftMarker.visible = false; // Keep marker hidden
      scene.add(leftMarker);
      
      // Right edge marker (green)
      const rightMarker = new THREE.Mesh(
        markerGeometry, 
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      rightMarker.position.set(newVisibleWidthAtZDepth/2, 0, 0);
      rightMarker.name = 'rightMarker';
      rightMarker.visible = false; // Keep marker hidden
      scene.add(rightMarker);
      
      // Center marker (blue)
      const originMarker = new THREE.Mesh(
        markerGeometry,
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
      );
      originMarker.position.set(0, 0, 0);
      originMarker.name = 'originMarker';
      originMarker.visible = false; // Keep marker hidden
      scene.add(originMarker);
      
      // Add updated center line
      const material = new THREE.LineBasicMaterial({ color: 0xffff00 });
      const points = [];
      points.push(new THREE.Vector3(-newVisibleWidthAtZDepth/2, 0, 0));
      points.push(new THREE.Vector3(newVisibleWidthAtZDepth/2, 0, 0));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(geometry, material);
      line.name = 'centerLine';
      line.visible = false; // Keep line hidden
      scene.add(line);
      
      console.log('Resize: updated viewport boundary markers:', {
        leftEdge: -newVisibleWidthAtZDepth/2,
        rightEdge: newVisibleWidthAtZDepth/2,
        center: 0
      });
      
      // Update camera position when orientation changes
      // Maintain camera centered on z-axis looking at origin
      camera.position.set(0, 0, cameraDistance);
      camera.lookAt(0, 0, 0);
      
      console.log('Resize: camera position maintained:', {
        position: camera.position.toArray(),
        lookAt: [0, 0, 0]
      });
      
      // Update center correction for the scene container with calculated values
      // Maintain the scene centered position during resizing
      // Keep the global center offset consistent across viewport changes
      sceneContainer.position.set(0, 0, 0);
      
      console.log('Resize: maintained centered scene position:', {
        sceneContainerPosition: sceneContainer.position.toArray()
      });
      
      // Calculate new width factor based on new aspect ratio
      const newScreenWidthFactor = newIsLandscape ? 0.85 : 0.85;
      const newCalculatedWidth = newVisibleWidthAtZDepth * newScreenWidthFactor;
      
      console.log('Resize: new width calculation:', {
        newScreenWidthFactor,
        newCalculatedWidth
      });
      
      // Apply new width calculation and scale adjustments to wave particles
      waves.forEach((wave, index) => {
        // Update the particle positions based on new viewport dimensions
        const positions = wave.geometry.attributes.position.array;
        const originalPositions = wave.userData.originalPositions;
        // Keep reference to initial distribution
        const initialDistances = wave.userData.initialDistances;
        const initialAngles = wave.userData.initialAngles;
        
        // FULL RESET on fullscreen toggle or significant resize
        if (isFullscreenToggle) {
          // Match initial wave parameters
          const waveHeight = 5 + index * 2.5;
          const waveOffset = 0;
          const waveType = index % 3;
          
          console.log(`Resize: COMPLETE RECREATION of Wave ${index} particles with EXACT width calculation`);
          
          // CRITICAL FIX: Use the EXACT same grid width and calculation approach as initial creation
          const gridWidth = Math.sqrt(positions.length / 3 * 4.2);
          
          // CRITICAL FIX: Use the EXACT same screen width factor as in initial creation
          const initialScreenWidthFactor = isLandscape ? 0.85 : 0.85;
          
          // CRITICAL FIX: Recreate calculatedWidth with the same algorithm as initial creation 
          const newCalculatedWidth = newVisibleWidthAtZDepth * initialScreenWidthFactor;
          
          console.log('Width comparison:', {
            originalVisibleWidth: visibleWidthAtZDepth,
            newVisibleWidth: newVisibleWidthAtZDepth,
            originalCalculatedWidth: calculatedWidth,
            newCalculatedWidth: newCalculatedWidth,
            ratio: newCalculatedWidth / calculatedWidth
          });
          
          // Store new cylindrical coordinates
          const newInitialDistances = new Float32Array(wave.userData.initialDistances.length);
          const newInitialAngles = new Float32Array(wave.userData.initialAngles.length);
          
          // COMPLETE RECREATION using IDENTICAL algorithm and IDENTICAL width calculation
          for (let i = 0; i < positions.length / 3; i++) {
            const ix = i * 3;
            
            // IDENTICAL grid distribution to initial creation
            const gridX = i % gridWidth;
            const gridZ = Math.floor(i / gridWidth);
            
            // IDENTICAL mapping to screen coordinates
            let screenPosition = (gridX / gridWidth) * 2 - 1; // Range from -1 to 1
            
            // IDENTICAL edge clustering
            const edgeClusteringFactor = 1.15;
            screenPosition = Math.sign(screenPosition) * Math.pow(Math.abs(screenPosition), edgeClusteringFactor);
            
            // CRITICAL FIX: Use the exact same distance but scaled proportionally to the new width
            // This ensures the cylindrical distribution matches the original
            const originalDistance = initialDistances[i];
            const distance = originalDistance * (newVisibleWidthAtZDepth / visibleWidthAtZDepth);
            
            // Get the angle from initialAngles 
            const angle = initialAngles[i];
            
            // Calculate the x position from screenPosition
            const scaleFactor = 1.0;
            const x = screenPosition * (newVisibleWidthAtZDepth / 2) * scaleFactor;
            
            // IDENTICAL conversion to cartesian coordinates
            const yVariation = Math.sin(angle) * distance;
            const zVariation = Math.cos(angle) * distance;
            
            // IDENTICAL Y and Z positioning
            const y = waveOffset + yVariation;
            const z = zVariation;
            
            // Set updated positions
            positions[ix] = x;
            positions[ix + 1] = y;
            positions[ix + 2] = z;
            
            // Update the original position reference
            originalPositions[ix] = x;
            originalPositions[ix + 1] = y;
            originalPositions[ix + 2] = z;
            
            // Store new cylindrical coordinates
            newInitialDistances[i] = distance;
            newInitialAngles[i] = angle;
          }
          
          // Update the stored cylindrical coordinates
          wave.userData.initialDistances = newInitialDistances;
          wave.userData.initialAngles = newInitialAngles;
          
          // Log for debugging
          if (index === 0) {
            // Log the first few particles for verification
            for (let i = 0; i < 5; i++) {
              const ix = i * 3;
              console.log(`Wave ${index} Particle ${i} After Reset:`, {
                x: positions[ix],
                y: positions[ix + 1],
                z: positions[ix + 2],
                distance: newInitialDistances[i],
                angle: newInitialAngles[i]
              });
            }
          }
        } else {
          // For normal resizes, just update the X positions while preserving Y and Z
          // Update the x positions of particles to fit the new viewport
          for (let i = 0; i < positions.length / 3; i++) {
            const ix = i * 3;
            const originalX = originalPositions[ix];
            
            // Get normalized position (-1 to 1)
            const normalizedPosition = originalX / (calculatedWidth / 2);
            
            // Apply new scale to fit the new viewport using the direct viewport mapping
            // Use the same updated scale factor as in initial creation for consistency
            const scaleFactor = 1.0; // Increased from 0.8 to match initial creation
            const newX = normalizedPosition * (newVisibleWidthAtZDepth / 2) * scaleFactor;
            positions[ix] = newX;
            originalPositions[ix] = newX; // Update original position for future animation
          }
        }
        
        // Mark the position attribute as needing update
        wave.geometry.attributes.position.needsUpdate = true;
        
        console.log(`Resize: Updated wave ${index} particle positions for new dimensions`);
      });
      
      // Apply constraints to ensure all particles are within the new viewport
      let particlesConstrained = 0;
      waves.forEach(wave => {
        // Apply more aggressive constraints during resize to ensure particles stay within viewport
        if (constrainParticlePosition(wave, newVisibleWidthAtZDepth * 0.9, newVisibleHeightAtZDepth * 0.9)) {
          particlesConstrained++;
        }
      });
      
      // Also constrain background particles for the new viewport
      if (backgroundParticleSystem) {
        if (isFullscreenToggle && backgroundParticleSystem.userData.initialPositions) {
          // Complete recreation of background particles using identical algorithm to initial creation
          const positions = backgroundParticleSystem.geometry.attributes.position.array;
          const initialPositions = backgroundParticleSystem.userData.initialPositions;
          const newInitialPositions = new Float32Array(initialPositions.length);
          
          // CRITICAL FIX: Use IDENTICAL creation parameters as initial creation
          const spreadFactor = newIsLandscape ? 0.9 : 0.8;
          const bgScaleFactor = 1.0;
          
          // CRITICAL FIX: Calculate the width ratio for proper scaling
          const widthRatio = newVisibleWidthAtZDepth / visibleWidthAtZDepth;
          const heightRatio = newVisibleHeightAtZDepth / visibleHeightAtZDepth;
          
          console.log('Background particle width ratio:', {
            widthRatio,
            heightRatio,
            visibleWidthAtZDepth,
            newVisibleWidthAtZDepth
          });
          
          for (let i = 0; i < positions.length / 3; i++) {
            const ix = i * 3;
            
            // CRITICAL FIX: Extract exact normalized position from initial creation
            // Instead of approximating with positionBias, use the exact original position
            const originalX = initialPositions[ix];
            
            // Scale X position proportionally to the new width
            const x = originalX * widthRatio;
            
            // Scale Y position proportionally to the new height
            const y = initialPositions[ix + 1] * heightRatio;
            
            // Keep Z the same
            const z = initialPositions[ix + 2];
            
            // Record first few positions for debugging
            if (i < 5) {
              console.log(`Background particle ${i}:`, {
                originalX,
                newX: x,
                ratio: x / originalX,
                widthRatio
              });
            }
            
            // Apply new positions
            positions[ix] = x;
            positions[ix + 1] = y;
            positions[ix + 2] = z;
            
            // Store new initial positions for future resize events
            newInitialPositions[ix] = x;
            newInitialPositions[ix + 1] = y;
            newInitialPositions[ix + 2] = z;
          }
          
          // Update the background particle system with new initial positions
          backgroundParticleSystem.userData.initialPositions = newInitialPositions;
          backgroundParticleSystem.geometry.attributes.position.needsUpdate = true;
          
          console.log('Background particles reset with exact proportional scaling');
        } else // For non-fullscreen toggle, just constrain the existing particles\r\n        // No need to update positions individually\r\n        if (constrainParticlePosition(backgroundParticleSystem, newVisibleWidthAtZDepth * 1.05, newVisibleHeightAtZDepth * 1.05)) {
          particlesConstrained++;
        }
      }
      
      console.log(`Resize: Constrained particles after resize: ${particlesConstrained} systems affected`);
      
      // Reset wave container position - no offsets needed with the container hierarchy
      wavesContainer.position.set(0, 0, 0);
      
      // Update renderer and composer with false flag to avoid changing CSS
      renderer.setSize(newWidth, newHeight, false);
      composer.setSize(newWidth, newHeight);
      
      // Make sure the renderer clear settings are maintained after resize
      renderer.setClearColor(theme === 'light' ? 0xffffff : 0x000011, 1);
      
      // Reapply theme-specific settings after resize
      if (theme === 'light') {
        console.log('DEBUG: Reapplying light mode renderer settings after resize');
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.NoToneMapping;
      } else {
        console.log('DEBUG: Reapplying dark mode renderer settings after resize');
        renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
      }
      
      // Make sure the renderPass clear settings are consistent too
      composer.passes.forEach(pass => {
        if (pass instanceof RenderPass) {
          pass.clearColor = theme === 'light' ? new THREE.Color(0xffffff) : new THREE.Color(0x000011);
          pass.clearAlpha = 1.0;
        }
      });
      
      // Log particle positions after resize to check for bounds issues
      setTimeout(() => {
        logPositionData(scene, camera, waves, backgroundParticleSystem, newVisibleWidthAtZDepth, newVisibleHeightAtZDepth, newCalculatedWidth);
        
        // Also verify that waves remain centered after resize
        console.log('Verifying centering after resize:');
        verifySceneCentering();
      }, 500); // Short delay to ensure positions have updated
    };
    
    // Start animation
    const animationId = requestAnimationFrame(animate);
    
    // Add event listeners
    window.addEventListener('resize', handleResize);
    renderer.domElement.addEventListener('mousemove', handleMouseMove);
    renderer.domElement.addEventListener('mouseleave', handleMouseLeave);
    renderer.domElement.addEventListener('mouseenter', () => {
      console.log('Mouse enter detected on canvas');
    });
    
    // Add mouse tracking to parent container as well
    if (mountRef.current) {
      const containerMouseMove = (event) => {
        // Only process if this is not already on the canvas
        if (event.target !== renderer.domElement) {
          handleMouseMove(event);
        }
      };
      
      mountRef.current.addEventListener('mousemove', containerMouseMove);
      
      // Store reference for cleanup
      const mountRefCurrent = mountRef.current;
      
      // Register original cleanup to be called after our additions
      const originalCleanup = () => {
        // Cancel animation loop
        cancelAnimationFrame(animationId);
        
        // Remove event listeners
        renderer.domElement.removeEventListener('mousemove', handleMouseMove);
        renderer.domElement.removeEventListener('mouseleave', handleMouseLeave);
        renderer.domElement.removeEventListener('mouseenter', () => {
          console.log('Mouse enter detected on canvas');
        });
        window.removeEventListener('resize', handleResize);
        
        // Remove container event listener
        if (mountRefCurrent) {
          mountRefCurrent.removeEventListener('mousemove', containerMouseMove);
        }
        
        // Continue with original cleanup
        if (mountRef.current && renderer.domElement) {
          mountRef.current.removeChild(renderer.domElement);
        }
        
        // Dispose of resources
        waves.forEach(wave => {
          if (wave.geometry) wave.geometry.dispose();
          if (wave.material) {
            if (wave.material.uniforms && wave.material.uniforms.pointTexture) {
              wave.material.uniforms.pointTexture.value.dispose();
            }
            wave.material.dispose();
          }
        });
        
        // Clean up background particles if they exist
        if (backgroundParticleSystem) {
          if (backgroundParticleSystem.geometry) {
            backgroundParticleSystem.geometry.dispose();
          }
          
          if (backgroundParticleSystem.material) {
            if (backgroundParticleSystem.material.uniforms && 
                backgroundParticleSystem.material.uniforms.pointTexture) {
              backgroundParticleSystem.material.uniforms.pointTexture.value.dispose();
            }
            backgroundParticleSystem.material.dispose();
          }
        }
        
        composer.dispose();
        renderer.dispose();
      };
      
      return originalCleanup;
    } else {
      // If mountRef is not available, just return the standard cleanup
      return () => {
        cancelAnimationFrame(animationId);
        
        renderer.domElement.removeEventListener('mousemove', handleMouseMove);
        renderer.domElement.removeEventListener('mouseleave', handleMouseLeave);
        window.removeEventListener('resize', handleResize);
        
        if (mountRef.current && renderer.domElement) {
          mountRef.current.removeChild(renderer.domElement);
        }
        
        // Continue with original disposal code...
      };
    }
  }, [theme]);
  
  // Use a wrapper div to ensure the container has dimensions before mounting Three.js
  return (
    <div className="wave-particles-container" 
      style={{ 
        width: '100%', 
        height: '100%', 
        position: 'relative', 
        overflow: 'hidden',
        cursor: 'none' // Hide cursor to enhance the interactive effect
      }}
    >
      <div 
        ref={mountRef} 
        style={{ 
          width: '100%', 
          height: '100%', 
          position: 'absolute',
          touchAction: 'none' // Prevent touch events from interfering
        }} 
      />
    </div>
  );
};

export default WaveformParticles; 
