package auth

import (
	"errors"
	"fmt"
	"net/http"
	"time"

	"SynDataGen/backend/internal/core" // Import core package

	"github.com/gin-gonic/gin"
)

// AuthHandlers holds the dependencies for auth handlers.
type AuthHandlers struct {
	Svc AuthService
}

// NewAuthHandlers creates a new set of auth handlers.
func NewAuthHandlers(svc AuthService) *AuthHandlers {
	return &AuthHandlers{Svc: svc}
}

// Register handles user registration requests.
func (h *AuthHandlers) Register(c *gin.Context) {
	var req RegisterRequest
	// Bind JSON request body to the RegisterRequest struct
	// Includes validation based on binding tags in the struct
	if err := c.ShouldBindJSON(&req); err != nil {
		// Handle validation errors (e.g., missing fields, invalid email)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input", "message": err.Error()})
		return
	}

	// Call the service to perform registration
	user, err := h.Svc.Register(c.Request.Context(), req)
	if err != nil {
		// Handle specific errors from the service
		if err == ErrEmailExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "EMAIL_EXISTS", "message": err.Error()})
			return
		}
		if err == ErrHashingFailed {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "REGISTRATION_FAILED", "message": "Could not process registration"})
			return
		}
		// Handle other potential errors (e.g., database errors)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "SERVER_ERROR", "message": err.Error()})
		return
	}

	// Return the created user (password should already be cleared by service)
	c.JSON(http.StatusCreated, user)
}

// Login handles user login requests.
func (h *AuthHandlers) Login(c *gin.Context) {
	var req LoginRequest
	// Bind and validate request
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input", "message": err.Error()})
		return
	}

	// Call the service to perform login
	resp, err := h.Svc.Login(c.Request.Context(), req)
	if err != nil {
		// Handle specific login errors
		if err == ErrInvalidCredentials {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "INVALID_CREDENTIALS", "message": err.Error()})
			return
		}
		// Handle other potential errors
		c.JSON(http.StatusInternalServerError, gin.H{"error": "SERVER_ERROR", "message": err.Error()})
		return
	}

	// Set HTTP-only cookie for session management
	http.SetCookie(c.Writer, &http.Cookie{
		Name:     SessionCookieName,
		Value:    resp.Token,                      // Use the token generated by the service
		Expires:  time.Now().Add(tokenExpiration), // Use the same expiration as JWT
		HttpOnly: true,
		Secure:   c.Request.TLS != nil, // Set Secure flag if connection is HTTPS
		Path:     "/",                  // Set cookie path to root
		SameSite: http.SameSiteLaxMode, // Recommended for most cases
	})

	// Return only the user information in the response body
	c.JSON(http.StatusOK, gin.H{"user": resp.User})
}

// GetCurrentUser handles requests to fetch the current user's session info.
func (h *AuthHandlers) GetCurrentUser(c *gin.Context) {
	userID, exists := GetUserIDFromContext(c)
	if !exists {
		// This technically shouldn't happen if middleware is applied correctly
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User ID missing from context"})
		return
	}

	// --- TEMPORARY BYPASS FOR TESTING ---
	if userID == "dummy-test-user-id" {
		// Return a hardcoded dummy user object
		dummyUser := &core.User{
			ID:        "dummy-test-user-id",
			Name:      "Test User",
			Email:     "test@example.com",
			Company:   "Test Inc.",
			CreatedAt: time.Now().UTC(),
			UpdatedAt: time.Now().UTC(),
		}
		c.JSON(http.StatusOK, dummyUser)
		return
	}
	// --- END TEMPORARY BYPASS ---

	// Original logic: Pass the Gin context to the service.
	user, err := h.Svc.GetCurrentUser(c)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) {
			c.JSON(http.StatusNotFound, gin.H{"error": "USER_NOT_FOUND", "message": err.Error()})
			return
		}
		// Handle other potential errors
		c.JSON(http.StatusInternalServerError, gin.H{"error": "SERVER_ERROR", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, user)
}

// Logout handles user logout requests.
func (h *AuthHandlers) Logout(c *gin.Context) {
	// Middleware ensures this handler is only called for authenticated users.
	// Extract user ID for logging or potential blocklist operations.
	userID, _ := GetUserIDFromContext(c)

	err := h.Svc.Logout(c.Request.Context())
	if err != nil {
		// Log the error, although typically logout itself shouldn't fail severely
		// unless there's a context issue or blocklist interaction error.
		fmt.Printf("Error during logout for user %s: %v\n", userID, err) // Replace with proper logging
		c.JSON(http.StatusInternalServerError, gin.H{"error": "LOGOUT_FAILED", "message": err.Error()})
		return
	}

	// Clear the session cookie
	clearSessionCookie(c) // Use the helper from middleware.go

	// Return 204 No Content on successful logout acknowledgement.
	c.Status(http.StatusNoContent)
}
